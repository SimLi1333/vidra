"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9217],{6590:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"topics/desicions/namespace","title":"Namespace Handling for Vidra-Managed Resources","description":"Context and Problem Statement","source":"@site/docs/topics/desicions/0009-namespace.mdx","sourceDirName":"topics/desicions","slug":"/topics/desicions/namespace","permalink":"/vidra/topics/desicions/namespace","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Namespace Handling for Vidra-Managed Resources","sidebar_position":10},"sidebar":"docsSidebar","previous":{"title":"Adopting GitOps Principles for Vidra Operator","permalink":"/vidra/topics/desicions/gitops"},"next":{"title":"Use of Finalizer for Resource Cleanup","permalink":"/vidra/topics/desicions/finalizer"}}');var a=s(4848),o=s(8453);const r={title:"Namespace Handling for Vidra-Managed Resources",sidebar_position:10},t="Namespace Handling for Vidra-Managed Resources",c={},d=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Consequences",id:"consequences",level:3}];function l(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"namespace-handling-for-vidra-managed-resources",children:"Namespace Handling for Vidra-Managed Resources"})}),"\n",(0,a.jsx)(n.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,a.jsxs)(n.p,{children:["As part of designing the Vidra Operator, we needed to decide how to handle the namespaces of resources managed by Vidra. Specifically, we considered whether each managed resource should have a distinct namespace, or if the namespace should be specified and handled within the ",(0,a.jsx)(n.code,{children:"InfrahubSync"})," Custom Resource Definition (CRD)."]}),"\n",(0,a.jsx)(n.p,{children:"This decision impacts how resources are organized, how access control is managed, and how flexible the operator is in supporting different deployment scenarios."}),"\n",(0,a.jsx)(n.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Distinct Namespace per Managed Resource"}),"\nIn this approach, each resource managed by Vidra is deployed into its own dedicated namespace. This provides strong isolation between resources, which can enhance security and reduce the risk of unintended interactions. However, it also increases the complexity of namespace management and makes resource discovery more challenging, as administrators must track and manage a larger number of namespaces."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Namespace Specified in InfrahubSync CRD:"}),(0,a.jsx)(n.br,{}),"\n","The namespace for each managed resource is defined within the ",(0,a.jsx)(n.code,{children:"InfrahubSync"})," CRD. This approach enables grouping multiple resources in a single namespace or distributing them as needed. It would imply that all resources in one artifact group (like Webserver) would be in one namespace. It simplifies management and aligns with Kubernetes patterns for multi-tenancy and resource grouping."]}),"\n",(0,a.jsx)(n.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Chosen option: both"}),", because we want to support as many deployment scenarios as possible.  The operator will use the namespace defined in the ",(0,a.jsx)(n.code,{children:"InfrahubSync"})," CRD as fallback, if the resources do not hace a namespace. This approach maximizes flexibility, allowing users to set a default namespace at the CRD level while still enabling per-resource overrides when needed."]}),"\n",(0,a.jsx)(n.h3,{id:"consequences",children:"Consequences"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Good, because it enables flexible resource organization, supports multi-tenancy, and reduces namespace sprawl."}),"\n",(0,a.jsx)(n.li,{children:"Bad, because it requires careful validation and documentation to ensure users specify namespaces correctly and understand the implications for access control and resource isolation."}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>t});var i=s(6540);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);