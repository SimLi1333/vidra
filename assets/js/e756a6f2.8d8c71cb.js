"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9403],{8453:(e,o,t)=>{t.d(o,{R:()=>r,x:()=>c});var n=t(6540);const s={},i=n.createContext(s);function r(e){const o=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function c(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(i.Provider,{value:o},e.children)}},8823:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"topics/desicions/transitioning-vidra-operator-to-cluster-scope","title":"Transitioning Vidra Operator to Cluster Scope","description":"Context and Problem Statement","source":"@site/docs/topics/desicions/0002-transitioning-vidra-operator-to-cluster-scope.md","sourceDirName":"topics/desicions","slug":"/topics/desicions/transitioning-vidra-operator-to-cluster-scope","permalink":"/vidra/topics/desicions/transitioning-vidra-operator-to-cluster-scope","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Use Markdown Architectural Decision Records","permalink":"/vidra/topics/desicions/use-markdown-architectural-decision-records"},"next":{"title":"Transitioning Vidra Operator to Cluster Scope","permalink":"/vidra/topics/desicions/creating-two-controller-which-work-together-in-a-modular-system"}}');var s=t(4848),i=t(8453);const r={},c="Transitioning Vidra Operator to Cluster Scope",a={},d=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2}];function l(e){const o={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.header,{children:(0,s.jsx)(o.h1,{id:"transitioning-vidra-operator-to-cluster-scope",children:"Transitioning Vidra Operator to Cluster Scope"})}),"\n",(0,s.jsx)(o.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,s.jsx)(o.p,{children:"We needed to decide whether the Controller should be namespace-scoped or cluster-scoped."}),"\n",(0,s.jsx)(o.p,{children:"While namespace-scoped Operators offer isolation, they are limited as they can not take ownership of resources in other namespaces. Our use case requires managing resources across multiple namespaces and potentially work with ownership could improve this."}),"\n",(0,s.jsx)(o.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsx)(o.li,{children:"Namespace-scoped controller and CRDs"}),"\n",(0,s.jsx)(o.li,{children:"cluster-scoped controller and CRD"}),"\n"]}),"\n",(0,s.jsx)(o.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,s.jsx)(o.p,{children:'Chosen option: "cluster-scoped controller and CRD", because While namespace-scoped is possible especaly in combination with finalizers to delete resources again, we do not want to lose the benefits of kubernetes ownership. We chose to go with cluster-scoped and leave us all options open to use ownership or finalizers to remove managed resources again.'})]})}function p(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);