"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6772],{587:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"topics/desicions/testing","title":"Testing Framework Decision","description":"Context and Problem Statement","source":"@site/docs/topics/desicions/0013-testing.md","sourceDirName":"topics/desicions","slug":"/topics/desicions/testing","permalink":"/vidra/topics/desicions/testing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"title":"Testing Framework Decision","sidebar_position":14},"sidebar":"cliSidebar","previous":{"title":"Storing Resource State","permalink":"/vidra/topics/desicions/resource-state"},"next":{"title":"Simplifying Vidra Operator Resource Provisioning with a CLI","permalink":"/vidra/topics/desicions/cli"}}');var i=n(4848),o=n(8453);const r={title:"Testing Framework Decision",sidebar_position:14},a="Testing Framework",d={},c=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Consequences",id:"consequences",level:3}];function l(e){const t={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"testing-framework",children:"Testing Framework"})}),"\n",(0,i.jsx)(t.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,i.jsxs)(t.p,{children:["Every real project needs to be tested. There are multiple testing libraries and frameworks to test Go applications, which can be used in addition to the default Go testing library. For our controllers (",(0,i.jsx)(t.code,{children:"infrahubsync"})," and ",(0,i.jsx)(t.code,{children:"vidraresource"}),") and adapter, we required a framework that supports comprehensive unit testing and integration-style tests, as our tests need to cover the entire reconciliation or setup process of the controller (not just single functions, but the whole logic block to bring the tests to a higher level). Clean code is maintained by splitting logic into multiple functions, all exercised by these tests."]}),"\n",(0,i.jsx)(t.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Testify"}),(0,i.jsx)(t.br,{}),"\n","A popular testing toolkit for Go that provides assertions, mocking, and more. However, it is primarily focused on unit testing and does not provide a structured way to write integration tests."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Ginkgo/Gomega"}),"\nA BDD-style (Behavior-driven development) testing framework that supports both unit and integration tests. It provides a rich set of assertions and allows for structured test organization, making it suitable for complex integration tests."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"GoSpec"}),"\nA lightweight BDD-style testing framework, but it lacks some of the advanced features and community support of Ginkgo/Gomega."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"GoConvey"}),"\nA testing framework that provides a web UI for test results and supports BDD-style tests. However, it is less commonly used in the Kubernetes community and does not integrate as well with the Operator SDK."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Chosen option: Ginkgo/Gomega"}),", because it is widely used in the Kubernetes community to test Kubernetes operators. It is also used in the Operator SDK project, which is leveraged by the Vidra Operator. Additionally, tests written with Ginkgo/Gomega are easy to read and understand."]}),"\n",(0,i.jsxs)(t.p,{children:["To facilitate testing, we used ",(0,i.jsx)(t.code,{children:"envtest"})," to provide a real Kubernetes API server environment. For dependency injection and mocking, we used ",(0,i.jsx)(t.code,{children:"mokgen"})," and custom-written mocks, especially for the adapter layer. The factory pattern was applied in the multicluster and event-based Kubernetes code to enable flexible test setups."]}),"\n",(0,i.jsx)(t.p,{children:"End-to-end (E2E) tests are performed using Cert-Manager and Prometheus. These tests deploy the Vidra Operator from the container registry into a real Kubernetes cluster, then monitor the operator's startup and behavior. This approach ensures that the operator works as expected in a production-like environment, validating integration with external components and overall system reliability."}),"\n",(0,i.jsx)(t.h3,{id:"consequences",children:"Consequences"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Good, because it aligns with community standards, improves readability, and supports integration-style testing."}),"\n",(0,i.jsx)(t.li,{children:"Bad, because it introduces an additional dependency and requires learning the Ginkgo/Gomega syntax."}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);