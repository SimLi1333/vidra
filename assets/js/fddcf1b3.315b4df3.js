"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3432],{3932:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"topics/desicions/operator-sdk","title":"Operator-SDK","description":"Context and Problem Statement","source":"@site/docs/topics/desicions/0003-operator-sdk.mdx","sourceDirName":"topics/desicions","slug":"/topics/desicions/operator-sdk","permalink":"/vidra/topics/desicions/operator-sdk","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Operator-SDK","sidebar_position":3},"sidebar":"cliSidebar","previous":{"title":"Transitioning Vidra Operator to Cluster Scope","permalink":"/vidra/topics/desicions/creating-two-controller-which-work-together-in-a-modular-system"},"next":{"title":"Transitioning Vidra Operator to Cluster Scope","permalink":"/vidra/topics/desicions/transitioning-vidra-operator-to-cluster-scope"}}');var s=t(4848),o=t(8453);const i={title:"Operator-SDK",sidebar_position:3},a="Operator-SDK",l={},d=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Consequences",id:"consequences",level:3},{value:"Links",id:"links",level:2}];function c(e){const n={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"operator-sdk",children:"Operator-SDK"})}),"\n",(0,s.jsx)(n.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,s.jsx)(n.p,{children:"Developing Kubernetes operators is simplified by using a dedicated SDK. An SDK abstracts much of the boilerplate and complexity, enabling faster and more reliable operator development. Several SDKs exist, each with different language support and features. Our requirement is an SDK that is robust, actively maintained, and supports Go."}),"\n",(0,s.jsx)(n.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Operator-SDK (Kubebuilder wrapper)"}),"\nFirst-class integration with Kubernetes APIs, Supports CRD generation, scaffolding, scorecard testing, metrics, and Helm/Ansible reuse. Used by many production-grade operators (e.g., Prometheus Operator)"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"KubeBuilder"}),"\nA framework for building Kubernetes APIs using CRDs and controllers. It provides a solid foundation but lacks some of the advanced features of Operator-SDK."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Metacontroller"}),"\nA framework for building Kubernetes controllers that can manage multiple resources. It is more focused on composition and less on full operator capabilities."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Daisy"}),"\nA lightweight framework for building Kubernetes controllers in YAML, but it lacks the comprehensive features and tooling of Operator-SDK."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"KOPF (Kubernetes Operator Python Framework)"}),"\nA Python-based framework for building Kubernetes operators. While we have more experience with Python, it does not align with our Go-based development stack."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:'Chosen option: "Cluster-scoped controller and CRD"'}),", because:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Operator-SDK provides a comprehensive set of tools for building, testing, and deploying operators."}),"\n",(0,s.jsx)(n.li,{children:"It has strong community support and is widely adopted in the Kubernetes ecosystem."}),"\n",(0,s.jsx)(n.li,{children:"It integrates seamlessly with Go, which we need to create a robust continuous delivery operator for Infrahub."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Good, because it provides ",(0,s.jsx)(n.strong,{children:"flexibility, better visibility"}),", and aligns with ",(0,s.jsx)(n.strong,{children:"ownership and management patterns"})," in Kubernetes."]}),"\n",(0,s.jsx)(n.li,{children:"Bad, because not all teammembers are familiar with Go, but since there is more to this projet than just the operator, we can learn it together and split the work between team members with different language skills."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://sdk.operatorframework.io/",children:"Operator-SDK Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/extend-kubernetes/operator/",children:"Kubernetes: Tools to build an operator"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);