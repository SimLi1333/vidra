"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[236],{7478:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"concepts/features","title":"Features","description":"Vidra is a Kubernetes operator designed to manage custom resources with flexibility and safety in complex environments. Below is an overview of its core features and ongoing development focus areas.","source":"@site/docs/concepts/features.mdx","sourceDirName":"concepts","slug":"/concepts/features","permalink":"/vidra/concepts/features","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Features","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Concepts","permalink":"/vidra/concepts/"},"next":{"title":"Installing Vidra","permalink":"/vidra/guides/install"}}');var s=i(4848),a=i(8453);const l={title:"Features",sidebar_position:2},t="Vidra Operator \u2013 Feature Overview",c={},o=[{value:"Current Features",id:"current-features",level:2},{value:"Namespace Handling",id:"namespace-handling",level:3},{value:"Safe Handling of Name Changes",id:"safe-handling-of-name-changes",level:3},{value:"Multiple <code>VidraResource</code> Instances per <code>InfrahubSync</code>",id:"multiple-vidraresource-instances-per-infrahubsync",level:3},{value:"Shared Resource Management",id:"shared-resource-management",level:3},{value:"Efficient Caching",id:"efficient-caching",level:3},{value:"Helm Chart Deployment",id:"helm-chart-deployment",level:3},{value:"Multicluster Support",id:"multicluster-support",level:3},{value:"Continuous Delivery of Virtual Machines",id:"continuous-delivery-of-virtual-machines",level:3},{value:"Event-Driven Reconciliation",id:"event-driven-reconciliation",level:3},{value:"Finalizers for Safe Cleanup",id:"finalizers-for-safe-cleanup",level:3},{value:"Experimental Capabilities (Not Yet Fully Validated)",id:"experimental-capabilities-not-yet-fully-validated",level:2},{value:"Advanced CRDs",id:"advanced-crds",level:3},{value:"Future Improvements",id:"future-improvements",level:2},{value:"Webhook-Based Reconciliation <em>(Planned/In Progress)</em>",id:"webhook-based-reconciliation-plannedin-progress",level:3},{value:"Sync to Other Platforms",id:"sync-to-other-platforms",level:3},{value:"Enhanced Observability",id:"enhanced-observability",level:3},{value:"User Interface",id:"user-interface",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"vidra-operator--feature-overview",children:"Vidra Operator \u2013 Feature Overview"})}),"\n",(0,s.jsx)(n.p,{children:"Vidra is a Kubernetes operator designed to manage custom resources with flexibility and safety in complex environments. Below is an overview of its core features and ongoing development focus areas."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"current-features",children:"Current Features"}),"\n",(0,s.jsx)(n.h3,{id:"namespace-handling",children:"Namespace Handling"}),"\n",(0,s.jsx)(n.p,{children:"Vidra tracks and manages resource ownership across namespaces, ensuring consistency and preventing conflicts during the resource lifecycle."}),"\n",(0,s.jsx)(n.h3,{id:"safe-handling-of-name-changes",children:"Safe Handling of Name Changes"}),"\n",(0,s.jsx)(n.p,{children:"Vidra includes logic to safely manage resource renames:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Detects renamed resources and reconciles to the desired state"}),"\n",(0,s.jsx)(n.li,{children:"Cleans up old resources to avoid orphaned objects"}),"\n",(0,s.jsx)(n.li,{children:"Ensures safe reconciliation after name updates"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"multiple-vidraresource-instances-per-infrahubsync",children:["Multiple ",(0,s.jsx)(n.code,{children:"VidraResource"})," Instances per ",(0,s.jsx)(n.code,{children:"InfrahubSync"})]}),"\n",(0,s.jsxs)(n.p,{children:["Supports creating multiple ",(0,s.jsx)(n.code,{children:"VidraResource"})," instances from a single ",(0,s.jsx)(n.code,{children:"InfrahubSync"}),", enabling:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Management of multiple resources from one Infrahub artifact"}),"\n",(0,s.jsxs)(n.li,{children:["Simplified configuration without duplicating ",(0,s.jsx)(n.code,{children:"InfrahubSync"})," definitions"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"shared-resource-management",children:"Shared Resource Management"}),"\n",(0,s.jsxs)(n.p,{children:["Allows multiple ",(0,s.jsx)(n.code,{children:"VidraResource"})," instances to manage the same Kubernetes resource:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Enables shared ownership (e.g., namespaces) across different ",(0,s.jsx)(n.code,{children:"VidraResource"})," and ",(0,s.jsx)(n.code,{children:"InfrahubSync"})," configurations"]}),"\n",(0,s.jsx)(n.li,{children:"Prevents deletion of resources still in use by other managers"}),"\n",(0,s.jsx)(n.li,{children:"Tracks ownership to ensure safe lifecycle operations"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"efficient-caching",children:"Efficient Caching"}),"\n",(0,s.jsx)(n.p,{children:"Vidra downloads artifacts only if the checksum has changed, reducing unnecessary network calls and improving performance."}),"\n",(0,s.jsx)(n.h3,{id:"helm-chart-deployment",children:"Helm Chart Deployment"}),"\n",(0,s.jsx)(n.p,{children:"Vidra is available as a Helm chart, allowing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Flexible deployment configurations"}),"\n",(0,s.jsx)(n.li,{children:"Easy integration into Helm-based infrastructure"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"multicluster-support",children:"Multicluster Support"}),"\n",(0,s.jsx)(n.p,{children:"Vidra supports multi-cluster environments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Uses ",(0,s.jsx)(n.code,{children:"kubeconfig"})," contexts to read/write across clusters"]}),"\n",(0,s.jsx)(n.li,{children:"Reconciles resources consistently across multiple environments"}),"\n",(0,s.jsx)(n.li,{children:"Maintains unique identity and ownership tracking per cluster"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"continuous-delivery-of-virtual-machines",children:"Continuous Delivery of Virtual Machines"}),"\n",(0,s.jsxs)(n.p,{children:["Supports continuous delivery of ",(0,s.jsx)(n.code,{children:"VirtualMachine"})," resources via ",(0,s.jsx)(n.a,{href:"https://kubevirt.io",children:"KubeVirt"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automates creation and updates based on Infrahub artifacts"}),"\n",(0,s.jsx)(n.li,{children:"Continuously reconciles VM state with the desired configuration"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"event-driven-reconciliation",children:"Event-Driven Reconciliation"}),"\n",(0,s.jsx)(n.p,{children:"Vidra uses an event-driven model to trigger reconciliation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Responds immediately to resource changes"}),"\n",(0,s.jsx)(n.li,{children:"Dynamically adds Informers only for managed resources"}),"\n",(0,s.jsx)(n.li,{children:"Minimizes overhead while supporting any Kubernetes resource type"}),"\n",(0,s.jsx)(n.li,{children:"Reduces latency in updates and syncs"}),"\n",(0,s.jsxs)(n.li,{children:["Can be enabled per ",(0,s.jsx)(n.code,{children:"InfrahubSync"})," or globally"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"finalizers-for-safe-cleanup",children:"Finalizers for Safe Cleanup"}),"\n",(0,s.jsx)(n.p,{children:"Finalizers ensure that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Resources are not deleted during processing"}),"\n",(0,s.jsx)(n.li,{children:"Dependencies are properly handled before deletion"}),"\n",(0,s.jsx)(n.li,{children:"Cleanup logic is safely executed"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"experimental-capabilities-not-yet-fully-validated",children:"Experimental Capabilities (Not Yet Fully Validated)"}),"\n",(0,s.jsx)(n.p,{children:"Vidra\u2019s architecture supports advanced scenarios that are available but not yet fully tested:"}),"\n",(0,s.jsx)(n.h3,{id:"advanced-crds",children:"Advanced CRDs"}),"\n",(0,s.jsx)(n.p,{children:"Potential for managing complex CRDs such as:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Network configurations (e.g., Kubenet)"}),"\n",(0,s.jsx)(n.li,{children:"Cloud-native infrastructure (e.g., Crossplane)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These capabilities are technically feasible but require further testing and validation before being considered production-ready."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,s.jsxs)(n.h3,{id:"webhook-based-reconciliation-plannedin-progress",children:["Webhook-Based Reconciliation ",(0,s.jsx)(n.em,{children:"(Planned/In Progress)"})]}),"\n",(0,s.jsx)(n.p,{children:"Vidra is evolving toward a fully event-based Continuous Integration Operator. Planned webhook support will:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Trigger real-time reconciliation on Infrahub changes"}),"\n",(0,s.jsx)(n.li,{children:"Reduce update latency"}),"\n",(0,s.jsx)(n.li,{children:"Provide more immediate feedback and state syncing"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sync-to-other-platforms",children:"Sync to Other Platforms"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"VidraResource"})," abstraction is independent of Infrahub, allowing for future support of:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Helm"}),": Manage resources via Helm charts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Git"}),": Enable GitOps-style syncing from repositories"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other platforms"}),": Any system providing Kubernetes manifests can be integrated"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"enhanced-observability",children:"Enhanced Observability"}),"\n",(0,s.jsx)(n.p,{children:"Upcoming improvements could include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Metrics and logging for operational insights"}),"\n",(0,s.jsx)(n.li,{children:"Tracing to follow resource lifecycle events"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"user-interface",children:"User Interface"}),"\n",(0,s.jsx)(n.p,{children:"Future plans may include a graphical interface to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Visualize resource state and dependencies"}),"\n",(0,s.jsx)(n.li,{children:"Provide dashboards for real-time monitoring and management"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>t});var r=i(6540);const s={},a=r.createContext(s);function l(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);